// package main

// import (
// 	"bridgebot/internal/blockchain/polygon"
// 	// "bridgebot/internal/blockchain/tron"
// 	"bridgebot/internal/client/http/bridgers"
// 	"bridgebot/internal/database"
// 	log "bridgebot/internal/utils/logger"
// 	"context"
// 	"fmt"
// 	"math/big"
// 	"os"
// 	"os/signal"
// 	"syscall"
// 	// "time"
// 	"github.com/ethereum/go-ethereum/common"
// 	"github.com/ethereum/go-ethereum/crypto"
// )

// // generateEquipmentNo ensures a fixed 32-character length for user addresses.
// func generateEquipmentNo(userAddr string) string {
// 	if len(userAddr) >= 32 {
// 		return userAddr[:32]
// 	}
// 	return fmt.Sprintf("%032s", userAddr) // Pad with zeros if less than 32
// }

// // // getUSDTAddress retrieves the USDT address from a given token map.
// // func getUSDTAddress(tokenMap map[string]string, symbol string) (string, error) {
// // 	address, exists := tokenMap[symbol]
// // 	if !exists {
// // 		return "", fmt.Errorf("USDT token not found on %s", symbol)
// // 	}
// // 	return address, nil
// // }

// func main() {
// 	log.Info("Starting Bridge Bot...")

// 	config := database.DBConfig{
// 		Username: "root",
// 		Password: "@Nima8228",
// 		Host:     "localhost",
// 		Port:     "3306",
// 	}

// 	err := database.InitializeDatabase(config)
// 	if err != nil {
// 		log.Fatalf("Failed to initialize database: %v", err)
// 	}

// 	db, err := database.Connect(config)
// 	if err != nil {
// 		log.Fatalf("Error connecting to the database: %v", err)
// 	}

// 	// Ensure the correct database is selected
// 	err = db.Exec("USE bridgebot_config").Error
// 	if err != nil {
// 		log.Fatalf("Error switching to database: %v", err)
// 	}

// 	var bridgeConfigs []database.BridgeConfiguration
// 	err = db.Find(&bridgeConfigs).Error
// 	if err != nil {
// 		log.Fatalf("Error fetching data from the database: %v", err)
// 	}

// 	// Create a nested map for easy access
// 	tokenMap := make(map[string]map[string]database.TokenInfo)

// 	// Loop through the records and populate the map
// 	for _, config := range bridgeConfigs {
// 		// Initialize the inner map for each token if it doesn't exist
// 		if _, exists := tokenMap[config.Token]; !exists {
// 			tokenMap[config.Token] = make(map[string]database.TokenInfo)
// 		}

// 		// Add the data for the specific network (e.g., BSC, Polygon)
// 		tokenMap[config.Token][config.Network] = database.TokenInfo{
// 			ChainID:                      config.ChainID,
// 			TokenContractAddress:         config.TokenContractAddress,
// 			TokenDecimals:                config.TokenDecimals,
// 			BridgersSmartContractAddress: config.BridgersSmartContractAddress,
// 			IsEnabled:                    config.IsEnabled,
// 		}
// 	}

// 	// Create a root context with cancellation support
// 	ctx, cancel := context.WithCancel(context.Background())
// 	defer cancel()

// 	// Handle OS signals to gracefully shutdown
// 	sigs := make(chan os.Signal, 1)
// 	signal.Notify(sigs, os.Interrupt, syscall.SIGTERM)
// 	go func() {
// 		<-sigs
// 		log.Warn("Received termination signal. Shutting down gracefully...")
// 		cancel()
// 		os.Exit(0)
// 	}()
// 	userAddr := "0x7d0F13148e85A53227c65Ed013E7961A67839858"

// 	// Fetch tokens
// 	// chains := []string{"POLYGON", "BSC"}
// 	// crossChainTokens := make(map[string]string)

// 	// for _, chain := range chains {
// 	// 	if err := bridgers.FetchAndMapTokens(ctx, chain, crossChainTokens); err != nil {
// 	// 		log.Error(err.Error())
// 	// 		return
// 	// 	}
// 	// }

// 	// // Retrieve USDT token addresses
// 	// usdtTRX, err := getUSDTAddress(crossChainTokens, "USDT(TRON)")
// 	// if err != nil {
// 	// 	log.Error(err.Error())
// 	// 	return
// 	// }

// 	// usdtBSC, err := getUSDTAddress(crossChainTokens, "USDT(BSC)")
// 	// if err != nil {
// 	// 	log.Error(err.Error())
// 	// 	return
// 	// }

// 	usdtBSC := tokenMap["USDT"]["BSC"]
// 	usdtPolygon := tokenMap["USDT"]["POL"]

// 	// Quote request
// 	request := bridgers.QuoteRequest{
// 		FromTokenAddress: usdtPolygon.TokenContractAddress,
// 		ToTokenAddress:   usdtBSC.TokenContractAddress,
// 		FromTokenAmount:  "3500000",
// 		FromTokenChain:   "POLYGON",
// 		ToTokenChain:     "BSC",
// 		UserAddr:         "",
// 		EquipmentNo:      generateEquipmentNo(userAddr),
// 		SourceFlag:       "WLXBridgeApp",
// 		SourceType:       "",
// 	}

// 	response, err := bridgers.RequestQuote(ctx, request)
// 	if err != nil {
// 		log.Errorf("Error fetching quote: %v", err)
// 		return
// 	}

// 	log.Info("Quote Response: We Get " + response.Data.TxData.ToTokenAmount + " USDT(BSC) for " + response.Data.TxData.FromTokenAmount + " USDT(POLYGON)")
// 	// fmt.Println("############## ##### USDT(POLYGON) to USDT(BSC)")
// 	// fmt.Println("############## ##### FromTokenAmount: ", response.Data.TxData.FromTokenAmount, "in POLYGON")
// 	// fmt.Println("############## ##### ToTokenAmount: ", response.Data.TxData.ToTokenAmount, "in BSC")

// 	// privateKey := "73643967cb61b7e712370b97e8fadde9fe866d1809eec00bc484dd9fe2a7b8f3"

// 	// // Create a TRON client with timeout-based context
// 	// log.Info("Creating a client and Connecting to TRON network...")
// 	// trxCtx, trxCancel := context.WithTimeout(ctx, 10*time.Second)
// 	// defer trxCancel()

// 	// client, err := tron.NewTronClient()
// 	// if err != nil {
// 	// 	log.Errorf("Error connecting to TRON network: %v", err)
// 	// 	return
// 	// }

// 	// // Check if approval is needed
// 	// walletAddr := "TMGcWzEDiECVCwAxoprCedtXSeuJthq4AA"
// 	// log.Info("Checking if approval is needed...")

// 	// needsApproval, approvedAmount, err := tron.IsApprovalNeeded(trxCtx, client, walletAddr)
// 	// if err != nil {
// 	// 	log.Errorf("Error checking approval status: %v", err)
// 	// 	return
// 	// }

// 	// log.Infof("Current approval amount: %s USDT (TRC-20 units)", approvedAmount.String())
// 	// log.Infof("Current approval amount: %s USDT ", approvedAmount.Div(approvedAmount, big.NewInt(1e6)).String())

// 	// if !needsApproval {
// 	// 	log.Info("This wallet is already approved, no further approval is needed.")
// 	// } else {
// 	// 	// Execute approval with a timeout context
// 	// 	approveCtx, approveCancel := context.WithTimeout(ctx, 20*time.Second)
// 	// 	defer approveCancel()

// 	// 	txHash, err := tron.ApproveContract(approveCtx, client, privateKey)
// 	// 	if err != nil {
// 	// 		log.Errorf("Error executing approval: %v", err)
// 	// 		return
// 	// 	}

// 	// 	log.Infof("Approval transaction successfully submitted! Tx Hash: %s", txHash)
// 	// 	log.Infof("Check the transaction on TronScan: https://nile.tronscan.org/#/transaction/%s", txHash)
// 	// }

// 	// receiverAddr := "0x5aA96F60C1aFf555c43552931a177728f32fcA27"
// 	receiverAddr := "0x7d0F13148e85A53227c65Ed013E7961A67839858"

// 	owner := common.HexToAddress("0x7d0F13148e85A53227c65Ed013E7961A67839858")
// 	spender := common.HexToAddress("0x7d0F13148e85A53227c65Ed013E7961A67839858")
// 	requiredAmount := big.NewInt(5500000)

// 	log.Info("Creating a client and Connecting to TRON network...")
// 	client, err := polygon.NewPolygonClient()
// 	if err != nil {
// 		log.Fatalf("Error initializing Polygon client: %v", err)
// 	}
// 	tokenAddress := common.HexToAddress("0xc2132d05d31c914a87c6611c10748aeb04b58e8f")

// 	log.Info("Checking if approval is needed...")
// 	isNeeded, err := polygon.IsApprovalNeeded(client, tokenAddress, owner, spender, requiredAmount)
// 	if err != nil {
// 		log.Fatalf("Error checking approval status: %v", err)
// 	}

// 	if isNeeded {
// 		log.Info("Approval is needed!!!")
// 		privateKeyHex := "dde619e9c94141eb5c60cf3c52e812f95db0a593543767a59e6b12e133a40c6d"
// 		privateKey, err := crypto.HexToECDSA(privateKeyHex)
// 		if err != nil {
// 			log.Fatalf("Failed to convert private key: %v", err)
// 		}

// 		txHash, err := polygon.ApproveContract(client, tokenAddress, spender, requiredAmount, privateKey)
// 		if err != nil {
// 			log.Fatalf("Error approving contract: %v", err)
// 		}

// 		log.Infof("Approval successful! Transaction hash: %s\n", txHash)
// 	} else {
// 		log.Info("Approval is already granted!")
// 	}

// 	// 	{
// 	//     "equipmentNo": "0x7d0F13148e85A53227c65Ed013E796",
// 	//     "sourceType": "H5",
// 	//     "userNo": "",
// 	//     "sessionUuid": "",
// 	//     "orderId": "",
// 	//     "sourceFlag": "bridgers",
// 	//     "utmSource": "",
// 	//     "fromTokenAddress": "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
// 	//     "toTokenAddress": "0x55d398326f99059ff775485246999027b3197955",
// 	//     "fromAddress": "0x7d0F13148e85A53227c65Ed013E7961A67839858",
// 	//     "toAddress": "0x7d0F13148e85A53227c65Ed013E7961A67839858",
// 	//     "fromTokenChain": "POLYGON",
// 	//     "toTokenChain": "BSC",
// 	//     "fromTokenAmount": "5500000",
// 	//     "amountOutMin": "5173500000000000000",
// 	//     "fromCoinCode": "USDT(POL)",
// 	//     "toCoinCode": "USDT(BSC)",
// 	//     "slippage": "0.05"
// 	// }

// 	CallDataRequest := bridgers.CallDataRequest{
// 		FromTokenAddress: usdtPolygon.TokenContractAddress,
// 		ToTokenAddress:   usdtBSC.TokenContractAddress,
// 		FromAddress:      receiverAddr,
// 		ToAddress:        receiverAddr,
// 		FromTokenChain:   "POLYGON",
// 		ToTokenChain:     "BSC",
// 		FromTokenAmount:  "5500000",             // 100 USDT (USDT has 6 decimals)
// 		AmountOutMin:     "5173500000000000000", // Expected min amount after slippage
// 		FromCoinCode:     "USDT(POL)",
// 		ToCoinCode:       "USDT(BSC)",
// 		EquipmentNo:      generateEquipmentNo(userAddr),
// 		SourceType:       "H5",
// 		SourceFlag:       "bridgers",
// 		Slippage:         "0.2",
// 		UserNo:           "",
// 		SessionUuid:      "",
// 		OrderId:          "",
// 		UtmSource:        "",
// 	}
// 	log.Info("Prepare Bridge Transaction Data ...")
// 	callData, err := bridgers.FetchBridgeCallData(ctx, CallDataRequest)
// 	if err != nil {
// 		log.Errorf("Swap request failed: %v", err)
// 		panic(err)
// 	}

// 	log.Infof("Transaction Destination : %s", callData.Data.TxData.To)

// 	// Execute the transaction using calldata
// 	log.Info("Executing Bridge Transaction on TRON...")

// 	// Set transaction parameters
// 	// contractAddress := callData.Data.TxData.To               // Smart contract address
// 	contractAddress := common.HexToAddress(callData.Data.TxData.To) // Convert to common.Address

// 	// functionSignature := callData.Data.TxData.FunctionName   // Function to be called
// 	calldata := callData.Data.TxData.Parameter // Encoded parameters for the contract call
// 	// feeLimit := int64(callData.Data.TxData.Options.FeeLimit) // Maximum POLYGON fee allowed
// 	// callValue := int64(0)                                    // No POLYGON is being sent in this contract call

// 	// Convert parameters to JSON string format
// 	calldataStr := "["
// 	for i, param := range calldata {
// 		calldataStr += fmt.Sprintf(`{"type":"%s","value":"%s"}`, param.Type, param.Value)
// 		if i < len(calldata)-1 {
// 			calldataStr += ","
// 		}
// 	}
// 	calldataStr += "]"
// 	privateKeyHex := "dde619e9c94141eb5c60cf3c52e812f95db0a593543767a59e6b12e133a40c6d"
// 	privateKey, err := crypto.HexToECDSA(privateKeyHex)
// 	if err != nil {
// 		log.Fatalf("Failed to convert private key: %v", err)
// 	}
// 	calldataBytes := []byte(calldataStr)

// 	// Broadcast transaction with calldata
// 	txHash, err := polygon.BroadcastTransactionWithCalldata(client, contractAddress, calldataBytes, privateKey)
// 	if err != nil {
// 		log.Errorf("Error executing bridge transaction: %v", err)
// 		return
// 	}

// 	log.Infof("Bridge transaction successfully submitted! Tx Hash: %s", txHash)
// 	log.Infof("Check the transaction on PolygonScan: https://polygonscan.com/tx/%s", txHash)
// }

// // Broadcast transaction
// // 	txHash, err := tron.BroadcastTransactionWithCalldata(ctx, client, contractAddress, functionSignature, calldataStr, privateKey, feeLimit, callValue)
// // 	if err != nil {
// // 		log.Errorf("Error executing bridge transaction: %v", err)
// // 		return
// // 	}

// // 	log.Infof("Bridge transaction successfully submitted! Tx Hash: %s", txHash)
// // 	log.Infof("Check the transaction on TronScan: https://nile.tronscan.org/#/transaction/%s", txHash)
// // }

// // package main

// // import (
// // 	"fmt"
// // 	"log"
// // 	"math/big"
// // 	"github.com/ethereum/go-ethereum/crypto"
// // 	"github.com/ethereum/go-ethereum/common"
// // 	"bridgebot/internal/blockchain/polygon"
// // )

// // func main() {
// // 	owner := common.HexToAddress("0x7d0F13148e85A53227c65Ed013E7961A67839858")
// // 	spender := common.HexToAddress("0x7d0F13148e85A53227c65Ed013E7961A67839858")
// // 	requiredAmount := big.NewInt(2000000)

// // 	client, err := polygon.NewPolygonClient()
// // 	if err != nil {
// // 		log.Fatalf("Error initializing Polygon client: %v", err)
// // 	}
// // 	tokenAddress := common.HexToAddress("0xc2132d05d31c914a87c6611c10748aeb04b58e8f")

// // 	isNeeded, err := polygon.IsApprovalNeeded(client, tokenAddress, owner, spender, requiredAmount)
// // 	if err != nil {
// // 		log.Fatalf("Error checking approval status: %v", err)
// // 	}

// // 	if isNeeded {
// // 		fmt.Println("Approval is needed!")
// // 		privateKeyHex := "dde619e9c94141eb5c60cf3c52e812f95db0a593543767a59e6b12e133a40c6d" // Replace with your actual private key
// // 		privateKey, err := crypto.HexToECDSA(privateKeyHex)
// // 		if err != nil {
// // 			log.Fatalf("Failed to convert private key: %v", err)
// // 		}

// // 		txHash, err := polygon.ApproveContract(client, tokenAddress, spender, requiredAmount, privateKey)
// // 		if err != nil {
// // 			log.Fatalf("Error approving contract: %v", err)
// // 		}

// // 		fmt.Printf("Approval successful! Transaction hash: %s\n", txHash)
// // 	} else {
// // 		fmt.Println("Approval is already granted!")
// // 	}
// // }